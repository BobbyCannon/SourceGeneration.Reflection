using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace SourceGeneration.Reflection;

public partial class ReflectionSourceGenerator
{
    private static void Emit(SourceProductionContext context, List<SourceTypeInfo> types, CancellationToken cancellationToken)
    {
        CSharpCodeBuilder builder = new();

        foreach (SourceTypeInfo type in types)
        {
            cancellationToken.ThrowIfCancellationRequested();

            EmitType(builder, type, cancellationToken);

            context.AddSource($"__SourceReflectorInitializer.{type.FullName.Replace('<', '[').Replace('>', ']')}.g.cs", builder.ToString());
            builder.Clear();
        }


        builder.AppendAutoGeneratedComment();
        builder.AppendBlock("internal static partial class __SourceReflectorInitializer", () =>
        {
            builder.AppendLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
            builder.AppendBlock("public static void Initialize()", () =>
            {
                foreach (SourceTypeInfo type in types)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    builder.AppendLine($"global::SourceGeneration.Reflection.SourceReflector.Add({type.FullName.Replace('.', '_').Replace('>', '_').Replace('<', '_')});");
                }
            });
        });

        context.AddSource($"__SourceReflectorInitializer.g.cs", builder.ToString());
    }

    private static void EmitType(CSharpCodeBuilder builder, SourceTypeInfo type, CancellationToken cancellationToken)
    {
        builder.AppendLine("#pragma warning disable CS0612");
        builder.AppendLine("#pragma warning disable CS0618 ");
        builder.AppendLine();
        builder.AppendAutoGeneratedComment();
        builder.AppendBlock("internal static partial class __SourceReflectorInitializer", () =>
        {
            builder.AppendBlock($"private static readonly global::SourceGeneration.Reflection.SourceTypeInfo {type.FullName.Replace('.', '_').Replace('>', '_').Replace('<', '_')} =  new global::SourceGeneration.Reflection.SourceTypeInfo()", () =>
            {
                builder.AppendAssignment("Name", type.Name);
                builder.AppendAssignment("IsStatic", type.IsStatic);
                builder.AppendAssignment("IsRecord", type.IsRecord);
                builder.AppendAssignment("IsStruct", type.IsStruct);
                builder.AppendAssignment("IsEnum", type.IsEnum);
                builder.AppendAssignment("IsReadOnly", type.IsReadOnly);

                builder.AppendLine($"Type = typeof({type.FullGlobalName}),");
                if (type.BaseType != null)
                {
                    builder.AppendLine($"BaseType = typeof({type.BaseType}),");
                }
                if (type.EnumUnderlyingType != null)
                {
                    builder.AppendLine($"EnumUnderlyingType = typeof({type.EnumUnderlyingType}),");
                }

                if (!type.IsStatic)
                {
                    builder.AppendLine($"ArrayType = typeof({type.FullGlobalName}[]),");
                }

                builder.AppendLine($"Accessibility = global::SourceGeneration.Reflection.SourceAccessibility.{type.Accessibility},");

                if (type.Fields.Count > 0)
                {
                    builder.AppendBlock("DeclaredFieldsInitializer = static () => new global::SourceGeneration.Reflection.SourceFieldInfo[]", () =>
                    {
                        foreach (var field in type.Fields)
                        {
                            cancellationToken.ThrowIfCancellationRequested();

                            EmitField(builder, type, field);
                        }
                    }, ",");
                }
                else
                {
                    builder.AppendLine("DeclaredFieldsInitializer = static () => global::System.Array.Empty<global::SourceGeneration.Reflection.SourceFieldInfo>(),");
                }

                if (type.Properties.Count > 0)
                {
                    builder.AppendBlock("DeclaredPropertiesInitializer = static () => new global::SourceGeneration.Reflection.SourcePropertyInfo[]", () =>
                    {
                        foreach (var property in type.Properties)
                        {
                            cancellationToken.ThrowIfCancellationRequested();

                            EmitProperty(builder, type, property);
                        }
                    }, ",");
                }
                else
                {
                    builder.AppendLine("DeclaredPropertiesInitializer = static () => global::System.Array.Empty<global::SourceGeneration.Reflection.SourcePropertyInfo>(),");
                }

                if (type.Methods.Count > 0)
                {
                    builder.AppendBlock("DeclaredMethodsInitializer = static () => new global::SourceGeneration.Reflection.SourceMethodInfo[]", () =>
                    {
                        foreach (var method in type.Methods)
                        {
                            cancellationToken.ThrowIfCancellationRequested();

                            EmitMethod(builder, type, method);
                        }
                    }, ",");
                }
                else
                {
                    builder.AppendLine("DeclaredMethodsInitializer = static () => global::System.Array.Empty<global::SourceGeneration.Reflection.SourceMethodInfo>(),");
                }

                if (type.Constructors.Count > 0)
                {
                    builder.AppendBlock("DeclaredConstructorsInitializer = static () => new global::SourceGeneration.Reflection.SourceConstructorInfo[]", () =>
                    {
                        foreach (var constructor in type.Constructors)
                        {
                            cancellationToken.ThrowIfCancellationRequested();

                            EmitConstructor(builder, type, constructor);
                        }
                    });
                }
                else
                {
                    builder.AppendLine("DeclaredConstructorsInitializer = static () => global::System.Array.Empty<global::SourceGeneration.Reflection.SourceConstructorInfo>(),");
                }
            }, ";");
        });
    }

    private static void EmitField(CSharpCodeBuilder builder, SourceTypeInfo type, SourceFieldInfo field)
    {
        builder.AppendIndent();
        builder.Append($"new global::SourceGeneration.Reflection.SourceFieldInfo(static () => typeof({type.FullGlobalName}).GetField(\"{field.Name}\", ");
        AppendBindingFlags(builder, field.Accessibility, field.IsStatic);
        builder.Append("))");
        builder.AppendLine();

        builder.AppendBlock(() =>
        {
            builder.AppendLine($"FieldType = typeof({field.FieldType}),");
            builder.AppendLine($"Accessibility = global::SourceGeneration.Reflection.SourceAccessibility.{field.Accessibility},");
            builder.AppendLine($"NullableAnnotation = global::SourceGeneration.Reflection.SourceNullableAnnotation.{field.NullableAnnotation},");
            builder.AppendAssignment("Name", field.Name);
            builder.AppendAssignment("IsStatic", field.IsStatic);
            builder.AppendAssignment("IsRequired", field.IsRequired);
            builder.AppendAssignment("IsReadOnly", field.IsReadOnly);
            builder.AppendAssignment("IsConst", field.IsConst);

            if (!type.IsGenericTypeDefinition &&
                !type.IsRefLikeType &&
                field.Accessibility != Accessibility.Private && field.Accessibility != Accessibility.Protected)
            {
                if (field.IsConst)
                {
                    builder.AppendLine($@"GetValue = static _ => {CSharpCodeBuilder.GetConstantLiteral(field.ConstantValue)},");
                }
                else if (field.IsStatic)
                {
                    builder.AppendLine($@"GetValue = static instance => {type.FullGlobalName}.{field.Name},");
                }
                else
                {
                    builder.AppendLine($@"GetValue = static instance => (({type.FullGlobalName})instance).{field.Name},");
                }

                if (!type.IsStruct && !field.IsReadOnly && !field.IsConst)
                {
                    if (field.IsStatic)
                    {
                        builder.AppendLine($@"SetValue = static (instance, value) => {type.FullGlobalName}.{field.Name} = ({field.FieldType})value");
                    }
                    else
                    {
                        builder.AppendLine($@"SetValue = static (instance, value) => (({type.FullGlobalName})instance).{field.Name} = ({field.FieldType})value");
                    }
                }
            }

        }, ",");
    }

    private static void EmitProperty(CSharpCodeBuilder builder, SourceTypeInfo type, SourcePropertyInfo property)
    {
        builder.AppendIndent();
        builder.Append($"new global::SourceGeneration.Reflection.SourcePropertyInfo(static () => typeof({type.FullGlobalName}).GetProperty(\"{property.Name}\", ");
        AppendBindingFlags(builder, property.Accessibility, property.IsStatic);
        builder.Append("))");
        builder.AppendLine();

        builder.AppendBlock(() =>
        {
            builder.AppendLine($"PropertyType = typeof({property.PropertyType}),");
            builder.AppendLine($"Accessibility = global::SourceGeneration.Reflection.SourceAccessibility.{property.Accessibility},");
            builder.AppendLine($"NullableAnnotation = global::SourceGeneration.Reflection.SourceNullableAnnotation.{property.NullableAnnotation},");
            builder.AppendAssignment("Name", property.Name);
            builder.AppendAssignment("IsVirtual", property.IsVirtual);
            builder.AppendAssignment("IsStatic", property.IsStatic);
            builder.AppendAssignment("IsRequired", property.IsRequired);
            builder.AppendAssignment("IsAbstract", property.IsAbstract);
            builder.AppendAssignment("IsInitOnly", property.IsInitOnly);
            builder.AppendAssignment("IsIndexer", property.IsIndexer);

            builder.AppendAssignment("CanWrite", property.CanWrite);
            builder.AppendAssignment("CanRead", property.CanRead);

            AppendParametersProperty(builder, "IndexerParameters", property.Parameters);

            if (!type.IsGenericTypeDefinition &&
                !type.IsRefLikeType &&
                property.Accessibility != Accessibility.Private && property.Accessibility != Accessibility.Protected)
            {
                if (property.CanRead && property.GetMethodAccessibility != Accessibility.Private && property.GetMethodAccessibility != Accessibility.Protected)
                {
                    if (property.IsStatic)
                    {
                        builder.AppendLine($@"GetValue = static instance => {type.FullGlobalName}.{property.Name},");
                    }
                    else
                    {
                        if (property.IsIndexer)
                        {
                            builder.AppendIndent();
                            builder.Append($@"GetIndexerValue = static (instance, parameters) => (({type.FullGlobalName})instance)[");
                            AppendMethodArguments(builder, property.Parameters);
                            builder.Append("],");
                            builder.AppendLine();
                        }
                        else
                        {
                            builder.AppendLine($@"GetValue = static instance => (({type.FullGlobalName})instance).{property.Name},");
                        }
                    }
                }

                if (!type.IsStruct && !property.IsInitOnly && property.CanWrite && property.SetMethodAccessibility != Accessibility.Private && property.SetMethodAccessibility != Accessibility.Protected)
                {
                    if (property.IsStatic)
                    {
                        builder.AppendLine($@"SetValue = static (instance, value) => {type.FullGlobalName}.{property.Name} = ({property.PropertyType})value");
                    }
                    else
                    {
                        if (property.IsIndexer)
                        {
                            builder.AppendIndent();
                            builder.Append($@"SetIndexerValue = static (instance, value, parameters) => (({type.FullGlobalName})instance)[");
                            AppendMethodArguments(builder, property.Parameters);
                            builder.Append($"] = ({property.PropertyType})value");
                            builder.AppendLine();
                        }
                        else
                        {
                            builder.AppendLine($@"SetValue = static (instance, value) => (({type.FullGlobalName})instance).{property.Name} = ({property.PropertyType})value");
                        }
                    }
                }
            }

        }, ",");
    }

    private static void EmitMethod(CSharpCodeBuilder builder, SourceTypeInfo type, SourceMethodInfo method)
    {
        builder.AppendIndent();

        if (method.IsGenericMethod)
        {
            builder.Append($"new global::SourceGeneration.Reflection.SourceMethodInfo(static () => global::SourceGeneration.Reflection.ReflectionExtensions.FindGenericMethod(typeof({type.FullGlobalName}), \"{method.Name}\", {method.TypeParameters.Length}, ");

            builder.AppendArrayInitializer("global::System.String", method.Parameters.Select(x => $"\"{x.DisplayType}\"").ToArray());
        }
        else
        {
            builder.Append($"new global::SourceGeneration.Reflection.SourceMethodInfo(static () => typeof({type.FullGlobalName}).GetMethod(\"{method.Name}\", ");
            AppendBindingFlags(builder, method.Accessibility, method.IsStatic);
            builder.Append(", ");
            builder.AppendArrayInitializer("global::System.Type", method.Parameters.Select(x => $"typeof({x.ParameterType})").ToArray());
        }
        builder.Append("))");
        builder.AppendLine();

        builder.AppendBlock(() =>
        {
            builder.AppendLine($"Accessibility = global::SourceGeneration.Reflection.SourceAccessibility.{method.Accessibility},");
            if (method.ReturnType != null)
            {
                builder.AppendLine($"ReturnType = typeof({method.ReturnType}),");
            }
            builder.AppendLine($"ReturnNullableAnnotation = global::SourceGeneration.Reflection.SourceNullableAnnotation.{method.ReturnNullableAnnotation},");

            builder.AppendAssignment("Name", method.Name);
            builder.AppendAssignment("IsStatic", method.IsStatic);

            AppendParametersProperty(builder, "Parameters", method.Parameters);

            if (!type.IsGenericTypeDefinition && !type.IsRefLikeType && method.CanInvoke())
            {
                builder.AppendIndent();
                builder.Append("Invoke = static (instance, parameters) => ");

                if (method.ReturnType == "void")
                {
                    builder.Append("{ ");
                }

                if (method.IsStatic)
                {
                    builder.Append($"{type.FullGlobalName}.{method.Name}(");
                }
                else
                {
                    builder.Append($"(({type.FullGlobalName})instance).{method.Name}(");
                }
                for (int i = 0; i < method.Parameters.Count; i++)
                {
                    SourceParameterInfo parameter = method.Parameters[i];
                    if (parameter.IsTypeParameter)
                    {
                        var typeParameter = method.TypeParameters.First(x => x.Name == parameter.ParameterType);
                        if (typeParameter.ConstraintTypes.Length == 0)
                        {
                            builder.Append($"parameters[{i}]");
                        }
                        else
                        {
                            builder.Append($"({typeParameter.ConstraintTypes[0]})parameters[{i}]");
                        }
                    }
                    else
                    {
                        builder.Append($"({parameter.ParameterType})parameters[{i}]");
                    }

                    if (i < method.Parameters.Count - 1)
                    {
                        builder.Append(", ");
                    }
                }
                builder.Append(")");

                if (method.ReturnType == "void")
                {
                    builder.Append("; return null; }");
                }

                builder.AppendLine();
            }

        }, ",");
    }

    private static void EmitConstructor(CSharpCodeBuilder builder, SourceTypeInfo type, SourceConstructorInfo constructor)
    {
        builder.AppendIndent();
        builder.Append($"new global::SourceGeneration.Reflection.SourceConstructorInfo(static () => typeof({type.FullGlobalName}).GetConstructor(");
        AppendBindingFlags(builder, constructor.Accessibility, constructor.IsStatic);
        builder.Append(", ");
        builder.AppendArrayInitializer("global::System.Type", constructor.Parameters.Select(x => $"typeof({x.ParameterType})").ToArray());
        builder.Append("))");
        builder.AppendLine();

        builder.AppendBlock(() =>
        {
            builder.AppendLine($"Accessibility = global::SourceGeneration.Reflection.SourceAccessibility.{constructor.Accessibility},");
            builder.AppendAssignment("Name", constructor.Name);
            builder.AppendAssignment("IsStatic", constructor.IsStatic);

            AppendParametersProperty(builder, "Parameters", constructor.Parameters);

            if (!type.IsGenericTypeDefinition &&
                !type.IsRefLikeType &&
                !constructor.Parameters.Any(x => x.IsParameterTypeRefLike || x.IsParameterTypePointer) &&
                constructor.Accessibility != Accessibility.Private && constructor.Accessibility != Accessibility.Protected &&
                !type.Properties.Any(x => x.IsRequired))
            {
                builder.AppendIndent();
                builder.Append($"Invoke = static (parameters) => new {type.FullGlobalName}(");
                AppendMethodArguments(builder, constructor.Parameters);
                builder.Append(")");
                builder.AppendLine();
            }

        }, ",");
    }

    private static void AppendMethodArguments(CSharpCodeBuilder builder, List<SourceParameterInfo> parameters)
    {
        for (int i = 0; i < parameters.Count; i++)
        {
            SourceParameterInfo parameter = parameters[i];
            builder.Append($"({parameter.ParameterType})parameters[{i}]");
            if (i < parameters.Count - 1)
            {
                builder.Append(", ");
            }
        }
    }

    private static void AppendBindingFlags(CSharpCodeBuilder builder, Accessibility accessibility, bool isStatic)
    {
        if (isStatic)
        {
            builder.Append("global::System.Reflection.BindingFlags.DeclaredOnly | global::System.Reflection.BindingFlags.Static");
        }
        else
        {
            builder.Append("global::System.Reflection.BindingFlags.DeclaredOnly | global::System.Reflection.BindingFlags.Instance");
        }

        if (accessibility == Accessibility.Public)
        {
            builder.Append(" | global::System.Reflection.BindingFlags.Public");
        }
        else
        {
            builder.Append(" | global::System.Reflection.BindingFlags.NonPublic");
        }
    }

    private static void AppendParametersProperty(CSharpCodeBuilder builder, string propertyName, List<SourceParameterInfo> parameters)
    {
        if (parameters.Count == 0)
        {
            builder.AppendLine($"{propertyName} = Array.Empty<global::SourceGeneration.Reflection.SourceParameterInfo>(),");
        }
        else
        {
            builder.AppendBlock($"{propertyName} = new global::SourceGeneration.Reflection.SourceParameterInfo[]", () =>
            {
                foreach (var parameter in parameters)
                {
                    builder.AppendBlock("new global::SourceGeneration.Reflection.SourceParameterInfo()", () =>
                    {
                        builder.AppendAssignment("Name", parameter.Name);
                        builder.AppendAssignment("HasDefaultValue", parameter.HasDefaultValue);
                        builder.AppendAssignment("DefaultValue", parameter.DefaultValue);
                        builder.AppendAssignment("IsRef", parameter.IsRef);
                        builder.AppendAssignment("IsOut", parameter.IsOut);

                        if (!parameter.HasNestedTypeParameter)
                        {
                            builder.AppendLine($"ParameterType = typeof({parameter.ParameterType}),");
                        }
                        builder.AppendLine($"NullableAnnotation = global::SourceGeneration.Reflection.SourceNullableAnnotation.{parameter.NullableAnnotation},");
                    }, ",");
                }
            }, ",");
        }
    }

}
